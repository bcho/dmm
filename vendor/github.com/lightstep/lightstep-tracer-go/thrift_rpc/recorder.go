package thrift_rpc

import (
	"fmt"
	"os"
	"path"
	"reflect"
	"runtime"
	"strconv"
	"strings"
	"sync"
	"sync/atomic"
	"time"

	"github.com/lightstep/lightstep-tracer-go/lightstep_thrift"
	"github.com/lightstep/lightstep-tracer-go/thrift_0_9_2/lib/go/thrift"
	"github.com/opentracing/basictracer-go"
	ot "github.com/opentracing/opentracing-go"
)

const (
	collectorPath = "/_rpc/v1/reports/binary"

	defaultPlainPort  = 80
	defaultSecurePort = 443

	defaultCollectorHost = "collector.lightstep.com"
	defaultAPIHost       = "api.lightstep.com"

	// See the comment for shouldFlush() for more about these tuning
	// parameters.
	defaultMaxReportingPeriod = 2500 * time.Millisecond
	minReportingPeriod        = 500 * time.Millisecond

	// ParentSpanGUIDKey is the tag key used to record the relationship
	// between child and parent spans.
	ParentSpanGUIDKey = "parent_span_guid"

	TracerPlatformValue = "go"
	TracerVersionValue  = "0.9.1"

	TracerPlatformKey        = "lightstep.tracer_platform"
	TracerPlatformVersionKey = "lightstep.tracer_platform_version"
	TracerVersionKey         = "lightstep.tracer_version"
	ComponentNameKey         = "lightstep.component_name"
	GUIDKey                  = "lightstep.guid" // <- runtime guid, not span guid
	HostnameKey              = "lightstep.hostname"
	CommandLineKey           = "lightstep.command_line"
)

// Endpoint describes a collection or web API host/port and whether or
// not to use plaintext communicatation.
type Endpoint struct {
	Host      string `yaml:"host" usage:"host on which the endpoint is running"`
	Port      int    `yaml:"port" usage:"port on which the endpoint is listening"`
	Plaintext bool   `yaml:"plaintext" usage:"whether or not to encrypt data send to the endpoint"`
}

// A set of counter values for a given time window
type counterSet struct {
	droppedSpans int64
}

// Options control how the LightStep Tracer behaves.
type Options struct {
	// AccessToken is the unique API key for your LightStep project.  It is
	// available on your account page at https://app.lightstep.com/account
	AccessToken string `yaml:"access_token" usage:"access token for reporting to LightStep"`

	// Collector is the host, port, and plaintext option to use
	// for the collector.
	Collector Endpoint `yaml:"collector"`

	// Tags are arbitrary key-value pairs that apply to all spans generated by
	// this Tracer.
	Tags ot.Tags

	// LightStep is the host, port, and plaintext option to use
	// for the LightStep web API.
	LightStepAPI Endpoint `yaml:"lightstep_api"`

	// MaxBufferedSpans is the maximum number of spans that will be buffered
	// before sending them to a collector.
	MaxBufferedSpans int `yaml:"max_buffered_spans"`

	// ReportingPeriod is the maximum duration of time between sending spans
	// to a collector.  If zero, the default will be used.
	ReportingPeriod time.Duration `yaml:"reporting_period"`

	ReportTimeout time.Duration `yaml:"report_timeout"`

	// DropSpanLogs turns log events on all Spans into no-ops.
	DropSpanLogs bool `yaml:"drop_span_logs"`

	// Set Verbose to true to enable more text logging.
	Verbose bool

	// In place of Flags
	MaxLogMessageLen int

	// MaxLogsPerSpan limits the number of logs in a single span.
	MaxLogsPerSpan int `yaml:"max_logs_per_span"`
}

// NewTracer returns a new Tracer that reports spans to a LightStep
// collector.
func NewTracer(opts Options) ot.Tracer {
	options := basictracer.DefaultOptions()
	options.ShouldSample = func(_ uint64) bool { return true }
	options.Recorder = NewRecorder(opts)
	options.DropAllLogs = opts.DropSpanLogs
	options.MaxLogsPerSpan = opts.MaxLogsPerSpan
	return basictracer.NewWithOptions(options)
}

func FlushLightStepTracer(lsTracer ot.Tracer) error {
	basicTracer, ok := lsTracer.(basictracer.Tracer)
	if !ok {
		return fmt.Errorf("Not a LightStep Tracer type: %v", reflect.TypeOf(lsTracer))
	}

	basicRecorder := basicTracer.Options().Recorder
	lsRecorder, ok := basicRecorder.(*Recorder)
	if !ok {
		return fmt.Errorf("Not a LightStep Recorder type: %v", reflect.TypeOf(basicRecorder))
	}
	lsRecorder.Flush()
	return nil
}

// Recorder buffers spans and forwards them to a LightStep collector.
type Recorder struct {
	lock sync.Mutex

	// auth and runtime information
	auth       *lightstep_thrift.Auth
	attributes map[string]string
	startTime  time.Time

	// Time window of the data to be included in the next report.
	reportOldest   time.Time
	reportYoungest time.Time

	// buffered data
	buffer   spansBuffer
	counters counterSet // The unreported count

	lastReportAttempt  time.Time
	maxReportingPeriod time.Duration
	reportInFlight     bool
	// Remote service that will receive reports
	backend lightstep_thrift.ReportingService

	// apiURL is the base URL of the LightStep web API, used for
	// explicit trace collection requests.
	apiURL string

	// AccessToken is the access token used for explicit trace
	// collection requests.
	AccessToken string

	verbose bool

	// We allow our remote peer to disable this instrumentation at any
	// time, turning all potentially costly runtime operations into
	// no-ops.
	disabled bool

	// flags replacement
	maxLogMessageLen int
}

func NewRecorder(opts Options) *Recorder {
	if len(opts.AccessToken) == 0 {
		// TODO maybe return a no-op recorder instead?
		panic("LightStep Recorder options.AccessToken must not be empty")
	}
	if opts.Tags == nil {
		opts.Tags = make(map[string]interface{})
	}
	// Set some default attributes if not found in options
	if _, found := opts.Tags[ComponentNameKey]; !found {
		opts.Tags[ComponentNameKey] = path.Base(os.Args[0])
	}
	if _, found := opts.Tags[GUIDKey]; !found {
		opts.Tags[GUIDKey] = genSeededGUID()
	}
	if _, found := opts.Tags[HostnameKey]; !found {
		hostname, _ := os.Hostname()
		opts.Tags[HostnameKey] = hostname
	}
	if _, found := opts.Tags[CommandLineKey]; !found {
		opts.Tags[CommandLineKey] = strings.Join(os.Args, " ")
	}

	attributes := make(map[string]string)
	for k, v := range opts.Tags {
		attributes[k] = fmt.Sprint(v)
	}
	// Don't let the Options override these values. That would be confusing.
	attributes[TracerPlatformKey] = TracerPlatformValue
	attributes[TracerPlatformVersionKey] = runtime.Version()
	attributes[TracerVersionKey] = TracerVersionValue

	now := time.Now()
	rec := &Recorder{
		auth: &lightstep_thrift.Auth{
			AccessToken: thrift.StringPtr(opts.AccessToken),
		},
		attributes:         attributes,
		startTime:          now,
		reportOldest:       now,
		reportYoungest:     now,
		maxReportingPeriod: defaultMaxReportingPeriod,
		verbose:            opts.Verbose,
		apiURL:             getAPIURL(opts),
		AccessToken:        opts.AccessToken,
		maxLogMessageLen:   opts.MaxLogMessageLen,
	}
	rec.buffer.setDefaults()

	if opts.MaxBufferedSpans > 0 {
		rec.buffer.setMaxBufferSize(opts.MaxBufferedSpans)
	}

	timeout := 60 * time.Second
	if opts.ReportTimeout > 0 {
		timeout = opts.ReportTimeout
	}
	transport, err := thrift.NewTHttpPostClient(getCollectorURL(opts), timeout)
	if err != nil {
		rec.maybeLogError(err)
		return nil
	}
	rec.backend = lightstep_thrift.NewReportingServiceClientFactory(
		transport, thrift.NewTBinaryProtocolFactoryDefault())

	go rec.reportLoop()

	return rec
}

func (r *Recorder) RecordSpan(raw basictracer.RawSpan) {
	r.lock.Lock()
	defer r.lock.Unlock()

	// Early-out for disabled runtimes.
	if r.disabled {
		return
	}

	atomic.AddInt64(&r.counters.droppedSpans, int64(r.buffer.addSpans([]basictracer.RawSpan{raw})))
}

func (r *Recorder) Flush() {
	r.lock.Lock()

	if r.disabled {
		r.lock.Unlock()
		return
	}

	if r.reportInFlight == true {
		r.maybeLogError(fmt.Errorf("A previous Report is still in flight; aborting Flush()."))
		r.lock.Unlock()
		return
	}

	now := time.Now()
	r.lastReportAttempt = now
	r.reportYoungest = now

	rawSpans := r.buffer.current()
	// Convert them to thrift.
	recs := make([]*lightstep_thrift.SpanRecord, len(rawSpans))
	// TODO: could pool lightstep_thrift.SpanRecords
	for i, raw := range rawSpans {
		var joinIds []*lightstep_thrift.TraceJoinId
		var attributes []*lightstep_thrift.KeyValue
		for key, value := range raw.Tags {
			if strings.HasPrefix(key, "join:") {
				joinIds = append(joinIds, &lightstep_thrift.TraceJoinId{key, fmt.Sprint(value)})
			} else {
				attributes = append(attributes, &lightstep_thrift.KeyValue{key, fmt.Sprint(value)})
			}
		}
		logs := make([]*lightstep_thrift.LogRecord, len(raw.Logs))
		for j, log := range raw.Logs {
			thriftLogRecord := &lightstep_thrift.LogRecord{
				TimestampMicros: thrift.Int64Ptr(log.Timestamp.UnixNano() / 1000),
			}
			// In the deprecated thrift case, we can reuse a single "field"
			// encoder across all of the N log fields.
			lfe := logFieldEncoder{thriftLogRecord, r}
			for _, f := range log.Fields {
				f.Marshal(&lfe)
			}
			logs[j] = thriftLogRecord
		}

		// TODO implement baggage
		if raw.ParentSpanID != 0 {
			attributes = append(attributes, &lightstep_thrift.KeyValue{ParentSpanGUIDKey,
				strconv.FormatUint(raw.ParentSpanID, 16)})
		}

		recs[i] = &lightstep_thrift.SpanRecord{
			SpanGuid:       thrift.StringPtr(strconv.FormatUint(raw.Context.SpanID, 16)),
			TraceGuid:      thrift.StringPtr(strconv.FormatUint(raw.Context.TraceID, 16)),
			SpanName:       thrift.StringPtr(raw.Operation),
			JoinIds:        joinIds,
			OldestMicros:   thrift.Int64Ptr(raw.Start.UnixNano() / 1000),
			YoungestMicros: thrift.Int64Ptr(raw.Start.Add(raw.Duration).UnixNano() / 1000),
			Attributes:     attributes,
			LogRecords:     logs,
		}
	}

	// TODO the handling of droppedPending / droppedSpans is very
	// manual. Add abstraction for the second client-side count to
	// avoid duplicating all the atomic ops.
	droppedPending := atomic.SwapInt64(&r.counters.droppedSpans, 0)

	metrics := lightstep_thrift.Metrics{
		Counts: []*lightstep_thrift.MetricsSample{
			&lightstep_thrift.MetricsSample{
				Name:       "spans.dropped",
				Int64Value: &droppedPending,
			},
		},
	}
	req := &lightstep_thrift.ReportRequest{
		OldestMicros:    thrift.Int64Ptr(r.reportOldest.UnixNano() / 1000),
		YoungestMicros:  thrift.Int64Ptr(r.reportYoungest.UnixNano() / 1000),
		Runtime:         r.thriftRuntime(),
		SpanRecords:     recs,
		InternalMetrics: &metrics,
	}

	// Do *not* wait until the report RPC finishes to clear the buffer.
	// Consider the case of a new span coming in during the RPC: it'll be
	// discarded along with the data that was just sent if the buffers are
	// cleared later.
	r.buffer.reset()

	r.reportInFlight = true
	r.lock.Unlock() // unlock before making the RPC itself

	resp, err := r.backend.Report(r.auth, req)
	if err != nil {
		r.maybeLogError(err)
	} else if len(resp.Errors) > 0 {
		// These should never occur, since this library should understand what
		// makes for valid logs and spans, but just in case, log it anyway.
		for _, err := range resp.Errors {
			r.maybeLogError(fmt.Errorf("Remote report returned error: %s", err))
		}
	} else {
		r.maybeLogInfof("Report: resp=%v, err=%v", resp, err)
	}

	r.lock.Lock()
	r.reportInFlight = false
	if err != nil {
		// Restore the records that did not get sent correctly
		atomic.AddInt64(&r.counters.droppedSpans, int64(r.buffer.addSpans(rawSpans))+droppedPending)
		r.lock.Unlock()
		return
	}

	// Reset the buffers
	r.reportOldest = now
	r.reportYoungest = now

	// TODO something about timing
	r.lock.Unlock()

	if droppedPending != 0 {
		r.maybeLogInfof("client reported %d dropped spans", droppedPending)
	}

	for _, c := range resp.Commands {
		if c.Disable != nil && *c.Disable {
			r.Disable()
		}
	}
}

// caller must hold r.lock
func (r *Recorder) thriftRuntime() *lightstep_thrift.Runtime {
	runtimeAttrs := []*lightstep_thrift.KeyValue{}
	for k, v := range r.attributes {
		runtimeAttrs = append(runtimeAttrs, &lightstep_thrift.KeyValue{k, v})
	}
	return &lightstep_thrift.Runtime{
		StartMicros: thrift.Int64Ptr(r.startTime.UnixNano() / 1000),
		Attrs:       runtimeAttrs,
	}
}

func (r *Recorder) Disable() {
	r.lock.Lock()
	defer r.lock.Unlock()

	if r.disabled {
		return
	}

	fmt.Printf("Disabling Runtime instance: %p", r)

	r.buffer.reset()
	r.disabled = true
}

// Every minReportingPeriod the reporting loop wakes up and checks to see if
// either (a) the Runtime's max reporting period is about to expire (see
// maxReportingPeriod()), (b) the number of buffered log records is
// approaching kMaxBufferedLogs, or if (c) the number of buffered span records
// is approaching kMaxBufferedSpans. If any of those conditions are true,
// pending data is flushed to the remote peer. If not, the reporting loop waits
// until the next cycle. See Runtime.maybeFlush() for details.
//
// This could alternatively be implemented using flush channels and so forth,
// but that would introduce opportunities for client code to block on the
// runtime library, and we want to avoid that at all costs (even dropping data,
// which can certainly happen with high data rates and/or unresponsive remote
// peers).
func (r *Recorder) shouldFlush() bool {
	r.lock.Lock()
	defer r.lock.Unlock()

	if time.Now().Add(minReportingPeriod).Sub(r.lastReportAttempt) > r.maxReportingPeriod {
		// Flush timeout.
		r.maybeLogInfof("--> timeout")
		return true
	} else if r.buffer.len() > r.buffer.cap()/2 {
		// Too many queued span records.
		r.maybeLogInfof("--> span queue")
		return true
	}
	return false
}

func (r *Recorder) reportLoop() {
	// (Thrift really should do this internally, but we saw some too-many-fd's
	// errors and thrift is the most likely culprit.)
	switch b := r.backend.(type) {
	case *lightstep_thrift.ReportingServiceClient:
		// TODO This is a bit racy with other calls to Flush, but we're
		// currently assuming that no one calls Flush after Disable.
		defer b.Transport.Close()
	}

	tickerChan := time.Tick(minReportingPeriod)
	for range tickerChan {
		r.maybeLogInfof("reporting alarm fired")

		// Kill the reportLoop() if we've been disabled.
		r.lock.Lock()
		if r.disabled {
			r.lock.Unlock()
			break
		}
		r.lock.Unlock()

		if r.shouldFlush() {
			r.Flush()
		}
	}
}

func getCollectorURL(opts Options) string {
	return getURL(opts.Collector,
		defaultCollectorHost,
		collectorPath)
}

func getAPIURL(opts Options) string {
	return getURL(opts.LightStepAPI, defaultAPIHost, "")
}

func getURL(e Endpoint, host, path string) string {
	if e.Host != "" {
		host = e.Host
	}
	httpProtocol := "https"
	port := defaultSecurePort
	if e.Plaintext {
		httpProtocol = "http"
		port = defaultPlainPort
	}
	if e.Port > 0 {
		port = e.Port
	}
	return fmt.Sprintf("%s://%s:%d%s", httpProtocol, host, port, path)
}
